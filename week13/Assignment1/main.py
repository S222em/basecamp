# For this assignment, you are going to refactor/change the existing car parking program code from weeks 9, 10 and 11 for the last time. The current application is still not prepared for a bigger use. It uses multiple files, and even different kinds of files to keep the program's state. By refactoring the application to use sql we want achieve the following advantages
#
# Faster searching in larger datasets
# More consistent by only reading from one source
# using a query can make the code simpler
# Simpler for maintenance, only one database needs to be backuped.
# Extra:
# Instead of reading/writing a log file and storing the car parking machine state in a JSON file, you will use a database to replace this functionality completely. \ The database will contain information about checked-in and checked-out cars for all parking machines.
# The database system used for this assignment will be an SQLITE (version 3.x) database.
#
# Info:
# Before starting, check if sqlite3 has already been installed on your system.
# If not, information on how to install sqlite3 can be found on the SQLITE website: https://www.sqlite.org/
# The import sqlite3 line will load the installed python sqlite3 module for use in your program.
#
# Database:
# To keep track of this information you are given a database structure with a single table.
# This table has the following columns:
#
# id
# car_parking_machine
# license_plate
# check_in
# check_out
# parking_fee
# You can use the following code in your __init__ of CarParkingMachine class to connect with the database and create it if it does not exist:
#
# self.db_conn = sqlite3.connect(os.path.join(sys.path[0], 'carparkingmachine.db'))
# self.db_conn.execute(
#     '''CREATE TABLE IF NOT EXISTS parkings (
#         id INTEGER PRIMARY KEY AUTOINCREMENT,
#         car_parking_machine TEXT NOT NULL,
#         license_plate TEXT NOT NULL,
#         check_in TEXT NOT NULL,
#         check_out TEXT DEFAULT NULL,
#         parking_fee NUMERIC DEFAULT 0
#     );'''
# )
# Every row inserted in this PARKINGS table will represent a checked-in car at a specific car parking machine.
# When a car checks-out, the existing row has to be updated with the check-out date and the calculated parking fee.
# This way the table parkings will function as a log history of all parked cars.
# It will also provide insight if a specific license plate is already checked-in at a specific car parking machine (to prevent duplicate check-ins).
# The id (also called a primary key) of a row in the PARKINGS table will be automatically generated by the database using the built-in AUTOINCREMENT functionality (https://www.sqlite.org/autoinc.html).
# So no id needs to be provided while inserting a row into the PARKINGS table.
#
# Class CarParkingMachine:
# Add the following functionality to your existing car parking machine
#
# Methods:
# def find_by_id(self, id) -> ParkedCar:
# This method will search for a parked_car in the database based on the row ID an return a ParkedCar object with the data
# def find_last_checkin(self, license_plate) -> int:
# This method will search for the last row for a given license_plate that has NOT checked-out yet (return row ID if found)
# def insert(self, parked_car: ParkedCar) -> ParkedCar:
# This method will insert details of a created ParkedCar object and put the new row ID (from database) on the object, return the object with this new row ID
# def update(self, parked_car: ParkedCar) -> None:
# This method will update details of a ParkedCar object inside the database (update based on ParkedCar.id <- Datbase Row ID)
# Changes:
# The following functionality in your existing car parking machine program will be changed:
#
# Removed the usage of a log file when checking-in and checking-out cars.
# Adjust the ParkedCar class so it can store: id: int, license_plate: str, check_in: datetime, check_out: datetime, parking_fee: float
# car parking init: restore the state of parked cars for a car parking machine by retrieving rows from the PARKINGS table
# car parking check-in: insert a row into the PARKINGS to table instead of writing to the JSON state file.
# car parking check-out: update the row in the database with check_out time and parking_fee information.
# Adjust CarParkingReporter:
# Adjust the carparkingreporter in such a way that it uses the database for the reports
#
# Add the following menu item to carparkingreport:
# [C] Report all complete parkings over all parking machines for a specific car
#
# Input: license_plate
# Output: csv file example (semicolon separated):
#
# car_parking_machine;check_in;check_out;parking_fee
# cpm_north;09-21-2022 16:20:04;09-21-2022 17:20:30;5.00
# cpm_south;09-22-2022 14:11:03;09-23-2022 19:00:10;15.00

import math
import sqlite3
import weakref
from datetime import datetime


def adapt_datetime_iso(value):
    """
    Adapt datetime to iso format
    :param value:
    :return:
    """
    return value.isoformat(sep=" ", timespec="milliseconds")


def convert_datetime_iso(value):
    """
    Convert iso format to datetime
    :param value:
    :return:
    """
    return datetime.fromisoformat(value.decode())


sqlite3.register_adapter(datetime, adapt_datetime_iso)
sqlite3.register_converter("DATETIME", convert_datetime_iso)


def connect():
    """
    Creates a connection to the database
    :return:
    """
    connection = sqlite3.connect("carparkingmachine.db", detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES)

    connection.execute(
        '''CREATE TABLE IF NOT EXISTS parkings (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            car_parking_machine TEXT NOT NULL,
            license_plate TEXT NOT NULL,
            check_in DATETIME NOT NULL,
            check_out DATETIME DEFAULT NULL,
            parking_fee NUMERIC DEFAULT 0
        );'''
    )

    return connection


class ParkedCar:
    """
    A car parked in the car park
    """

    def __init__(self, id, license_plate, check_in, check_out, parking_fee):
        """
        Instantiates a new parked car
        :param id:
        :param license_plate:
        :param check_in:
        :param check_out:
        :param parking_fee:
        """
        self.id = id
        self.license_plate = license_plate
        self.check_in = check_in
        self.check_out = check_out
        self.parking_fee = parking_fee

    def get_hours_since_check_in(self):
        """
        Returns the hours since the car was checked in
        Maximum is 24 hours
        :return:
        """
        return min(math.ceil((datetime.now() - self.check_in).total_seconds() / 3600), 24)

    def to_parameters(self):
        """
        Converts this to a tuple of parameters, without id
        :return:
        """
        return self.license_plate, self.check_in, self.check_out, self.parking_fee


class CarParkingMachine:
    """
    Car parking machine
    Used to track parked cars and calculate fees
    """

    # Contains all instances to confirm whether a car is already parked somewhere else.
    # To make sure instances will not stay alive because of a reference here, WeakSet is used.
    INSTANCES = weakref.WeakSet()
    # So we can utilize the same connection
    connection = None

    def __init__(self, id, capacity=10, hourly_rate=2.50):
        """
        Instantiates a new car parking
        :param id: The ID of this carpark
        :param capacity: The maximum capacity of the car park, defaults to 10
        :param hourly_rate: The hourly rate of the car park, defaults to 2.50
        """
        self.id = id
        self.capacity = capacity
        self.hourly_rate = hourly_rate
        self.parked_cars = dict()

        if not CarParkingMachine.connection:
            CarParkingMachine.connection = connect()

        self._restore()

        CarParkingMachine.INSTANCES.add(self)

    def _restore(self):
        """
        Loads all previous parked cars from the database
        :return:
        """
        query = """SELECT id, license_plate, check_in AS "check_in [DATETIME]",
                    check_out AS "check_out [DATETIME]", parking_fee
                    FROM parkings
                    WHERE car_parking_machine=? AND check_out IS NULL"""
        parameters = (self.id,)

        cursor = CarParkingMachine.connection.execute(query, parameters)
        rows = cursor.fetchall()

        for row in rows:
            parked_car = ParkedCar(*row)
            self.parked_cars[parked_car.license_plate] = parked_car

    @staticmethod
    def is_car_checked_in(license_plate):
        """
        Whether the car is checked in on any instance
        :param license_plate:
        :return:
        """
        for instance in CarParkingMachine.INSTANCES:
            if license_plate in instance.parked_cars:
                return True

        return False

    def check_in(self, license_plate, check_in=datetime.now()):
        """
        Checks a car in if there is space left in the car park
        :param license_plate: The license plate of the to check in car
        :param check_in: The time the car was checked in, defaults to now
        :return:
        """
        if len(self.parked_cars) >= self.capacity or self.is_car_checked_in(license_plate):
            return False

        parked_car = ParkedCar(None, license_plate, check_in, None, 0)
        parked_car = self.insert(parked_car)
        self.parked_cars[license_plate] = parked_car

        return True

    def check_out(self, license_plate):
        """
        Check the car out of the park if it was there in the first place
        :param license_plate: The license plate of the car to check out
        :return:
        """
        if license_plate not in self.parked_cars:
            return None

        fee = self.get_parking_fee(license_plate)

        parked_car = self.parked_cars.pop(license_plate)
        parked_car.check_out = datetime.now()
        parked_car.parking_fee = fee
        self.update(parked_car)

        return fee

    def get_parking_fee(self, license_plate):
        """
        Returns the fee of a car in the park
        :param license_plate:
        :return:
        """
        return self.hourly_rate * self.parked_cars[license_plate].get_hours_since_check_in()

    @staticmethod
    def find_by_id(id):
        """
        Finds a specific parking by id, not limited by carpark
        :param id:
        :return:
        """
        query = """SELECT id, license_plate, check_in AS "check_in [DATETIME]",
                    check_out AS "check_out [DATETIME]", parking_fee
                    FROM parkings WHERE id=?;"""
        parameters = (id,)

        cursor = CarParkingMachine.connection.execute(query, parameters)
        row = cursor.fetchone()

        if not row:
            return None

        return ParkedCar(*row)

    @staticmethod
    def find_last_checkin(license_plate):
        """
        Find the last check in of a license plate, not limited by carpark
        :param license_plate:
        :return:
        """
        query = """SELECT id FROM parkings WHERE license_plate=? AND check_out IS NULL ORDER BY id DESC;"""
        parameters = (license_plate,)

        cursor = CarParkingMachine.connection.execute(query, parameters)
        row = cursor.fetchone()

        if not row:
            return None

        return row[0]

    def insert(self, parked_car):
        """
        Insert a new parked car into the database, connected with this carpark
        :param parked_car:
        :return:
        """
        query = """INSERT INTO parkings (car_parking_machine, license_plate, check_in, check_out, parking_fee)
                    VALUES (?, ?, ?, ?, ?);"""
        parameters = (
            self.id, *parked_car.to_parameters()
        )

        cursor = CarParkingMachine.connection.execute(query, parameters)
        CarParkingMachine.connection.commit()

        parked_car.id = cursor.lastrowid

        return parked_car

    def update(self, parked_car):
        """
        Update an existing parked car
        :param parked_car:
        :return:
        """
        query = """UPDATE parkings SET
            car_parking_machine=?, license_plate=?, check_in=?, check_out=?, parking_fee=?
            WHERE id=?;"""

        parameters = (self.id, *parked_car.to_parameters(), parked_car.id)

        CarParkingMachine.connection.execute(query, parameters)
        CarParkingMachine.connection.commit()


MENU_OPTIONS = """[I] Check-in car by license plate
[O] Check-out car by license plate
[Q] Quit program
"""


def main():
    """
    The main program
    :return:
    """

    car_parking = CarParkingMachine("Main")

    while True:
        stop = loop(car_parking)
        if stop:
            break


def loop(car_parking):
    """
    The main loop
    :param car_parking:
    :return: Whether the program should quit
    """
    menu_option = input(MENU_OPTIONS).strip().lower()

    if menu_option == "q":
        return True

    license_plate = input("License: ")

    if menu_option == "i":
        is_checked_in = car_parking.check_in(license_plate)
        print("License registered" if is_checked_in else "Capacity reached!")

    if menu_option == "o":
        parking_fee = car_parking.check_out(license_plate)

        if not parking_fee:
            print(f"License {license_plate} not found!")
        else:
            print(f"Parking fee: {parking_fee:.2f} EUR")

    return False


if __name__ == "__main__":
    main()
